"""
Base strategy class that all strategies inherit from.
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any
from enum import Enum
import pandas as pd


class SignalType(Enum):
    """Trading signal types."""
    NONE = 0
    BUY = 1
    SELL = -1


@dataclass
class Signal:
    """Trading signal generated by strategy."""
    type: SignalType
    price: float
    timestamp: pd.Timestamp
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Trade:
    """Completed trade record."""
    entry_time: pd.Timestamp
    exit_time: pd.Timestamp
    direction: SignalType  # BUY or SELL
    entry_price: float
    exit_price: float
    stop_loss: float
    take_profit: float
    size: float  # Position size
    pnl: float  # Profit/loss in price terms
    pnl_pips: float  # Profit/loss in pips
    exit_reason: str  # "TP", "SL", "BE", "TRAIL", "SIGNAL", "CLOSE"
    metadata: Dict[str, Any] = field(default_factory=dict)


class Strategy(ABC):
    """
    Base class for all trading strategies.

    Subclasses must implement:
        - generate_signals(df) -> List[Signal]
        - get_parameters() -> Dict[str, Any]

    Optional overrides:
        - on_bar(bar) -> Optional[Signal]  (for live trading)
    """

    name: str = "BaseStrategy"
    version: str = "1.0"

    def __init__(self, params: Optional[Dict[str, Any]] = None):
        """
        Initialize strategy with parameters.

        Args:
            params: Strategy parameters (overrides defaults)
        """
        self.params = self.get_default_parameters()
        if params:
            self.params.update(params)

    @abstractmethod
    def get_default_parameters(self) -> Dict[str, Any]:
        """Return default parameters for this strategy."""
        pass

    @abstractmethod
    def generate_signals(self, df: pd.DataFrame) -> List[Signal]:
        """
        Generate trading signals from historical data.

        Args:
            df: DataFrame with OHLCV data (indexed by time)

        Returns:
            List of Signal objects
        """
        pass

    def get_parameter_space(self) -> Dict[str, tuple]:
        """
        Return parameter ranges for optimization.

        Override in subclass. Format:
        {
            "param_name": (min, max, step),  # for int/float
            "param_name": [val1, val2, val3],  # for categorical
        }
        """
        return {}

    def on_bar(self, bar: pd.Series, position: Optional[Dict] = None) -> Optional[Signal]:
        """
        Process a single bar (for live trading).

        Override for custom live trading logic.

        Args:
            bar: Current bar data (open, high, low, close, volume)
            position: Current position info if any

        Returns:
            Signal if entry/exit, None otherwise
        """
        return None

    def __repr__(self):
        return f"{self.name}({self.params})"
